# nesgo - Golang tooling for the NES

[![Build status](https://github.com/retroenv/nesgo/actions/workflows/go.yaml/badge.svg?branch=main)](https://github.com/retroenv/nesgo/actions)
[![go.dev reference](https://img.shields.io/badge/go.dev-reference-007d9c?logo=go&logoColor=white&style=flat-square)](https://pkg.go.dev/github.com/retroenv/nesgo)
[![Go Report Card](https://goreportcard.com/badge/github.com/retroenv/nesgo)](https://goreportcard.com/report/github.com/retroenv/nesgo)
[![codecov](https://codecov.io/gh/retroenv/nesgo/branch/main/graph/badge.svg?token=NS5UY28V3A)](https://codecov.io/gh/retroenv/nesgo)

nesgo allows you to write programs for the Nintendo Entertainment System
(NES) in Golang. It offers additional tooling like a disassembler and emulator.

The benefits over other tooling options:

- Code autocompletion in any IDE that supports Golang
- The code can be debugged directly from an IDE at source level,
  it will be executed in the built-in Emulator
- Easy unit testing of code
- Simple code documentation generation
- Easy to installation of the command line tools

The code for NES programs is written using Aliases for 6502 assembly
instructions, this allows to have full control over the outputted
binary code. The compiler generates an .asm file that can be inspected.

**nesgo is in an early stage of development and needs more work before it
can be used to build a larger project for NES!**

## Installation

Your system needs to have a recent [Golang](https://go.dev/) version installed.

Install nesgo using `go install github.com/retroenv/nesgo/cmd/nesgo@latest`

Install [cc65](https://github.com/cc65/cc65), it is used for generating 
the final .nes file from assembly output generated by nesgo.
It is planned to remove this dependency in future versions. 

The integrated OpenGL GUI support is enabled by default. Debugging
your code will execute using the built-in Emulator and GUI.
To select the GUI mode to use, set the following build flags:

* `nogui`: disables all GUI modules
* `noopengl` `sdl` enables the SDL GUI

The following libraries need to be installed, 
depending on the operating system:

**macOS**: `Xcode or Command Line Tools for Xcode (xcode-select --install)`

**Ubuntu/Debian-like**: `build-essential libgl1-mesa-dev xorg-dev`

**CentOS/Fedora-like**: `@development-tools libX11-devel libXcursor-devel
 libXrandr-devel libXinerama-devel mesa-libGL-devel libXi-devel
 libXxf86vm-devel`

**Windows**:
  * Install [msys2](http://www.msys2.org/) 
  * Start msys2 and execute `pacman -S --needed base-devel
    mingw-w64-i686-toolchain mingw-w64-x86_64-toolchain
    mingw64/mingw-w64-x86_64-SDL2`
  * Add `c:\tools\msys64\mingw64\bin\` to user path environment variable

## Usage

See one of the examples on how to write code for the NES using Golang!

The first compilation can take a few minutes depending on the system,
this is due to Golang compiling the CGO GUI dependencies.

nesgo can be used in different ways:

1. Compile a project to a .nes file:
 `nesgo -f ./examples/blue/main.go -o ./examples/blue/main.nes`

2. Use `go build ./examples/blue/main.go` to compile the program as a
 static binary including the Emulator

3. Run the code in the Emulator using `go run ./examples/blue/main.go`

4. Debug the program using your IDE of choice using the Delve debugger,
 set breakpoints, watch memory or CPU register, execute the code step by step etc

5. Run the generated .nes file using the `go run ./cmd/nesgoemu -f examples/blue/main.nes`

## Project layout

    ├─ cmd/nesgo        Golang to NES compiler
    ├─ cmd/nesgodisasm  NES disassembler
    ├─ cmd/nesgoemu     NES emulator
    ├─ example/         Program examples in Golang
    ├─ internal/        internal compiler code
    ├─ pkg/             libraries used by different packages
    ├─ pkg/neslib       helper useful for writing NES programs

## Differences / Limitations

* `return` has to be used instead of `rts` - it will get automatically
  added at the end of functions that are not inlined
* `goto` has to be used instead of `jump` - it is limited to the labels in the
  current function as jump destination
* for instructions that accept multiple addressing modes, the parameters can be
  cast into a helper type to set the mode, using the identifiers
  `ZeroPage`, `Absolute` or `Indirect`. If the instruction supports
  an immediate parameter, it will be set by default
